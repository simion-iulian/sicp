## On the what of expressiveness
Reading chapter 1 I see why functional programming can be difficult to grasp to somebody coming from the imperative and object world. It's the conversation around abstraction vs concretions taken to a whole new level. By the end of the chapter I got to see how a procedure returned as a value provides two layers of abstraction in one place. The simplest attempt is to encapsulate the behavior in an object and make it domain specific rather than make the effort to find the generic way of abstracting the domain operation. There's also a cost to abstracting to a generic way. When going for a more generic way too early one might make the code harder to change, as well as spend a lot of effort to come up with the abstraction, so sometimes doing a few specific cases then finding the commonality is how you find whether it's worth doing it in a specific way or in a generic way.

Expressiveness is very powerful, yet in proportion to its power comes the necessity to understand how to use it. 
Expressiveness is taking multiple ideas and putting them in one place. Programming is far more about ideas than about programming languages, patterns or frameworks. It's about how ideas are travelling through the systems and programs and how ideas interact with other ideas. 
Expressiveness is about how clearly one makes the idea of a process to be understood in one place, as well as how it interacts with other ideas near it.
Expressiveness is about how easy it is to put an idea from the mind into code and how easy it is to read that idea afterwards. Jargon, complexity and fuzzy thinking lead to confusion. Expressiveness and clarity are the two wings of good programming. This means the code is easier to change when that is required and parts can work independently from one another. In this case it is easier to pay the technical debt. 

There also is a conceptual leap to make from thinking in objects to thinking in computational processes and data. I do find though that in both cases it is better to think first of how the code might change, rather than what the most expressive way of doing things. [A blog post about expressiveness vs ease of change](https://overreacted.io/goodbye-clean-code)

It took SICP about 70 pages to prove the point of how to write a program that's easy to be read. That is to say, it's not easy to write a program that is easy to be read without all the sophistry that goes behind how a computational process works. I think good naming goes in here, though it's not always possible to give a name to the process. The book [Data and Reality](https://www.amazon.com/Data-Reality-Perspective-Perceiving-Information/dp/1935504215) goes into depth about why even naming things is hard given it's not always easy to point at what is one thing and what is the same thing when trying to come up with a data model. If the data model cannot be precise then the computational process that works with that data will have to deal with these shortcoming. While the model becomes clearer the implementation needs to reflect this, otherwise making the new features work will be slow until the [technical debt](https://www.martinfowler.com/bliki/TechnicalDebt.html) is paid.
