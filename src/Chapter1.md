## On the what of expressiveness
Reading chapter 1 I get why functional programming can be so difficult to grasp to somebody coming from the imperative and objectual world. It's the conversation around abstraction vs concretions taken to a whole new level. By the end of the chapter I got to see how a procedure returned as a value provides two layers of abstraction in one place. It is easier to encapsulate the behavior in an object and make it domain specific rather than make the effort to find the generic way of abstracting the domain operation. It also makes it harder to communicate with other engineers and developers who are used to the object and procedural model, since they will be used to the patterns present in the language, as well as it's semantics. Expressiveness is very powerful, yet in proportion to its power comes the necessity to understand how to use it. Expressiveness is taking multiple ideas and putting them in one place. Programming is far more about ideas than about programming languages, patterns. It's about how ideas are travelling through the systems and programs and how ideas interact with ideas. Expressiveness is about how clearly one makes the idea of a process to be understood in one place, or what ideas or being used there.

It took SICP about 70 pages to prove the point of how to write a program that's easy to be read. That is to say it's not easy to write a program to be read without all the sophistry that goes behind how a computational process works. Therefore the idea behind expressiveness is to make it easier to understand a computational process and where to look for it rather than (What is a misconception about expressiveness) about how easy is to make something with a programming language (a la Ruby with the fancy syntactic sugar going on)

Therefore expresiveness should be part of the language but at the same time it would be good if it sits in its own layer. A layer where the concepts and abstractions are clear and then there is a layer underneath where it gets closer to what the machine does. One cannot do without the other if the program is to be well written.

Expressiveness is about how easy it is to put an idea from the mind into code and how easy it is to read that idea afterwards. Jargon, complexity and fuzzy thinking lead to confusion. Expressiveness and clarity are the two wings of good programming. 

**How can I learn to write expressive code?**
This is my own journey into learning to love programming. I notice how others love the puzzles, and it's important I'm fairly good at that too, there is no other way of tackling complexity without the love and the fun of the puzzle. Yet I find that limiting to be the only motivating factor in why I program and how I progress as a creator of programs. 

Therefore there is no other way than going through a lot of puzzles and in my attempts to solve them find my way of expressing them in intersting and exciting ways. This way I build my own vocabulary of tools and find the zen of programming. This is just blabber until I have explore my first study.

I also feel I'm putting aside the business aspects because I'm sliding again into programming as an art form instead of a craft. I love play, yet I get bored fast and it's easy for me to get distracted into all these thoughts. Therefore how can I show integrity and thrustworthiness about doing it well for somebody else. There are two types of users here: one who are technologically empowered, who are closer to the machine and the users who stand to take out (what benefits?).

## On the how
**How can I learn to write clear code?**
Exercises, Katas, Etudes, Projects, Prototypes. The clearer my thinking will about each of them the clearer the code will be too.
Examples and Blog Articles too.

## On the when

# Further ideas to explore
- Backwards reasoning - Programs and Maths
    - How To Solve It - maths
    - SICP & REPLs - programs
    - track the reasoning in making of a part of a program    
- Holding a program in one's head - as well as on paper 
- The REPL and the Notional Machine